\section{Lower bound $\Omega(k\cdot \ell)$}

\maciek{Warning: sketch only, I did not finish writing it yet!}

\maciek{I assume $\alpha = 1$ to simplify calculations, but everything should hold for general $\alpha$}

In this section we consider the Online Balanced Partition problem.
We show a lower bound of $\Omega(k \cdot \ell)$ that uses an input that has a perfect partition.
Therefore, this result is a lower bound for the general Online Balanced Partition problem, as well as a lower bound for Online Balanced Partition with perfect partition.
The latter complements an upper bound $O(k \cdot \ell)$ for Online Balanced Partition with perfect partition that we present in Section TODO.

\begin{theorem}
  The competitive ratio of any deterministic algorithm for Online Balanced Partition is $\Omega(k\cdot \ell)$.
\end{theorem}

\begin{proof}

  \maciek{Sequence $\lbrace \rbrace$ not the set notation}


 We say that an online algorithm DET is component-respecting if it never reaches a configuration with a component split between clusters.
  %Recall that if DET resides in a configuration with a component split between clusters, we issue intra-component requests until
   \maciek{If DET splits a component, we issue intra-component requests until DET joins it}
  
  Fix a deterministic algorithm DET.
  Fix a cluster $A$ containing nodes $a_1, \ldots, a_k$ and a cluster $B$ containing (among others) a node $b_1$.
  The adversary begins with issuing $k-2$ internal requests $(a_i, a_{i+1})$, so that nodes $a_1, \ldots a_{k-1}$ form a single component.
  The internal requests are free for OPT, and it doesn't perform additional actions at this point.
  The next request issued by the adversary is an external request $(a_k, b_1)$.%, which at this point is the request $(a_k, b)$.
  Note that DET must relocate the component $\{a_k, b_1\}$ to some other cluster.
  OPT also relocates the component $\{a_k, b_1\}$ to some carefuly chosen cluster $D$, and it evicts nodes $d^{(1)}$ and $d^{(2)}$ (to be fixed later) from $D$ to the previous locations of $a_k$ and $b_1$ (i.e., to the clusters $A$ and $B$).
  For these actions, OPT pays $2$, and DET pays at least $2$.
  We name the requests issued so far as $I_1$.


  Now, we construct a sequence of requests $I_2$, but we do not feed them to DET yet.
  Instead, we simulate DET's actions on $I_1I_2$ to terminate the input sequence earlier, i.e., we choose a prefix $I_2'$ of $I_2$ and we feed DET the input $I_1I_2'$.
  \maciek{We can produce $I_2'$ on-the-fly, but this was convinient to write it down this way}


  The input $I_2$ consists of requests $(x^{(1)}, c(x^{(1)})), (x^{(2)}, c(x^{(2)})),\ldots$.
  The node $x^{(i)}$ is a node in the current configuration of DET that is co-located in one cluster with the component $a_1, \ldots, a_{k-1}$.
  After a request $(x^{(i)}, c(x^{(i)}))$, the node $x^{(i)}$ is a part of a non-singleton component and must be relocated to some other cluster (as its current cluster hosts a component $a_1, \ldots, a_{k-1}$).
  Then, DET places the node $x^{(i+1)}$ in place of $x^{(i)}$, and the next request concerns that node.
  % Initially, $x^{(1)} = a_k$, and the next node $x^{(2)}$ is the that DET locates in place of the
  The sequence continues as long as after serving the request, a perfect partition of the input graph exists.

  For each $x^{(i)}$, we set $c(x^{(i)})$ to some node that in the initial configuration was co-located with $x^{(i)}$.
  While producing an input sequence, we would like to additionally order the initial nodes $V^C$ of each cluster (i.e., order the nodes that were present in each cluster in its initial configuration).
  The ordering needs to be produced on-the-fly, as this ordering is used to produce subsequent requests.
  
  %Note that in the initial configuration, nodes of one cluster are indistinguishible for DET \maciek{and hence we can order them on-the-fly}.
  
  Now, we formally define $c(x^{(i)})$, and the ordering of nodes in the initial configuration.
  Consider a set of nodes from an initial configuration of a cluster $C$ (where $C \neq A$).
  By $v^C_1$ we label the first node of a cluster $C$ that appears in the sequence $\{x^{(i)}\}$.
  At this point, we fix an arbitrary other node of $C$ and we label it $v^C_0$, and we set $c(v^C_i) = v^C_0$ for all $i$.
  For the following $k-2$ nodes of the cluster $C$, we label them $v^C_2, v^C_3, \ldots$ in the order of appearance in the sequence $\{x^{(i)}\}$.
  %For a node $v^C_p = x^{(j)}$, we set $y^{(j)} = v^C_0$.
  Some nodes of $C$ might never appear in the sequence $\{x^{(i)}\}$ (e.g. DET might terminate prematurely or might reside in a configuration with components split), and we number them arbitrarily, with the restriction that the nodes that do appear in the sequence have smaller number than the ones that do not.
  
  Now, we claim that given the input $I_1I_2$, every component-respecting DET 
  % (that does not terminate prematurely and never resides in a configuration with components split)
  must produce a sequence $\{x^{(i)}\}$ of length $L = k\cdot \ell - (k-1) - 2 - (\ell-1) - 1$.
  Consider a request $(x^{(i)}, c(x^{(i)})$.
  If in this configuration at least one singleton component is present (other than the components of $(x^{(i)}, c(x^{(i)})$), then serving this request is possible (i.e., the perfect partition exists), and a singleton node appears as $x^{(i+1)}$, and the sequence continues.
  Otherwise, as we have a component $a_1, \ldots, a_{k-1}$, no perfect partition exists.

  Hence, the length of a sequence $\{x^{(i)}\}$ depends on the number of singleton components.
  Before the arrival of the first request from $I_2$, the number of singleton components is $L + (\ell-1) + 1$, and after serving the last request, the number of singleton components is $1$.
  %Every node $x^{(i)}$ must be a singleton component, otherwise DET resides in a configuration with components split (and such DETs either leave such configuration eventually or issue an infinite cost).
  After each request, we join this singleton component with another component.
  This join decreases the number of singleton components by one or by two: if this is the join of two singletons $v^C_0, v^C_1$ (there are $\ell-1$ such joins: for all clusters but $A$), then the number of singletons decrease by $2$, and it decreases by $1$ otherwise.
  We conclude that the number of requests $\{x^{(i)}\}$ to decrease the number of singletons to $1$ is $L$.

  \medskip

  Now, we define the input $I_2'$ as a prefix of $I_2$.
  Recall that OPT serves the first external request $(a_k, b_1)$ by placing the component $\{a_k, b_1\}$ in some cluster $D$, and it evicts some nodes $d^{(1)}$ and $d^{(2)}$ from $D$ to the previous locations of $a_k$ and $b_1$.
  It remains to determine the cluster $D$ and nodes $d^{(1)}$ and $d^{(2)}$,
  and our aim is that OPT would not pay any cost for $I_2'$.
  As nodes $d^{(1)}$ and $d^{(2)}$ are not in their initial cluster, a request between a node from (intitial configuration of) $D$ and either $d^{(1)}$ or $d^{(2)}$ would not be free for OPT.
  
  
  At this point we already know the sequence $\{x^{(i)}\}$ of DET.
  For the requests of $I_2'$ to be free for OPT, it suffices to choose $v^D_0$ that is neither $d^{(1)}$ nor $d^{(2)}$,
  and to guarantee that $d^{(1)}$, $d^{(2)}$ does not appear in the sequence $\{x^{(i)}\}$, i.e., to finish the input sequence before that.
  Furthermore, we would like to guarantee the length of $\{x^{(i)}\}$ to remain $\Omega(k\cdot \ell)$.
  
  To this end, we inspect the sequences $v^{C}_i$ for each cluster, and select the cluster $C'$ whose node $v^{C'}_{k-2}$, i.e., the penultimate node appear last in the sequence $\{x^{(i)}\}$, and end the sequence $I_2'$ just before its appearance.
  Then, we set $d^{(1)} = v^{C'}_{k-2}$, $d^{(2)} = v^{C'}_{k-1}$.
  Such choice guarantees that requests from $I_2'$ are free for OPT.
  Furthermore, the number of requests of $I_2'$ is at least $|I_2| - \ell - 1$: as $D$ is the last cluster to remain with two singleton clusters, all other $\ell-1$ clusters have at most $1$ singleton cluster.

  Finally, OPT pays $2$, and DET pays $L - \ell - 1 = \Omega(\ell \cdot k)$.
  
  
 % During the runtime of DET, by $x(A)$ we denote the node in the configuration of DET that is co-located in one cluster with the component $a_1, \ldots, a_{k-1}$.

  

 % \maciek{Possibly we need a better name than $x(A)$. This should be tied to (1) DET, and (2) the component $a_1, \ldots, a_{k-1}$ (not the server A, from which it might be relocated by DET). Maybe we should number them, i.e., $x_1, x_2,\ldots$}
 % During the runtime of DET, by $x(A)$ we denote the node in the configuration of DET that is co-located in one cluster with the component $a_1, \ldots, a_{k-1}$.
 % Initially, $x(A) = a_k$.
 
 % We consider a sequence of requests between a node $x(A)$ and some other nodes, i.e., each request concerns the node that is currently co-located with the component $a_1,\ldots,a_{k-1}$.
 % As a result
  

  % Fix a node $m^C$ for each cluster $C$.
  
  % Note that nodes of one cluster are indistinguishible for DET.
  
  
 % For the purpose of constructing $I_2$, we order nodes of any cluster $C$: $v^C_1, \ldots, v^C_k$.
 % For any node $v^C_i\neq v^C_1$ we define $c(v^C_i) = v^C_1$, and $c(v^C_1) = v^C_2$.

  
  
  %Now, for a node $p$ we define $c(p)$ in the following way: for each node outside of $a_i$ and $b$, we define $c(p)$ to be any node that in the initial configuration was placed at the same cluster as $p$, and if $p$ belonged to $D$, then $c(p)$ is any such node that is different from $d_1$ and $d_2$.
  %\maciek{we have a cyclic reference at this point. D is not yet defined (depends on c), and c depends on d1, d2...}
  %Then, the adversary continues to issue requests $(x, c(x))$.
\end{proof}

\section{An $O(\ell)$-competitive algorithm for $k=3$}

\begin{theorem}
  The rebalancing cost for the greedy algorithm for $k=3$ is $O(1)$.
  \maciek{Greedy = find the cheapest (closest to the current) feasible partition}
  \label{rebalancing-cost}
\end{theorem}

\begin{proof} 
 \maciek{Note: we consider a cost of cheapest feasible rebalancing after insertion of one edge. This in contrast to bounding the distance between any two reconfigurations (this theorem does not bound the latter).}
  
  We distinguish among three configuration types of algorithm's clusters: $C_1, C_2, C_3$. In $C_1$ we have $3$ singleton components (this is also the initial configuration of any cluster). In $C_2$ we have one component of size $2$ and one component of size $1$. Finally, in $C_3$ we have one component of size $3$.

  Consider a request $(u, v)$ and let $U, V$ be their clusters.
  If $U=V$, then the request does not require a reconfiguration.
  Now, we consider cases upon the type of clusters $U$ and $V$.
  Note that this is impossible that either $U$ or $V$ is $C_3$ as otherwise the resulting component would have the size $4$, and this contradicts the existence of the perfect partition.
  If either $U$ or $V$ is $C_1$, then either cluster can fit the merged component, and the rebalance is local within $U$ and $V$, for the cost of at most $3$ migrations.

  Now, we focus on the case where both $U$ and $V$ are $C_2$. Note that $(u,v)$ cannot both belong to a component of size $2$, as the merged component would have size $4$.
  If either $u$ or $v$ belongs to a component of size $2$ then it suffices to exchange components of size $1$ between $U$ and $V$.
  Finally, if $u$ and $v$ belong to components of size $1$, then we must place them in a cluster different from $U$ and $V$.
  Note that in such case, a $C_1$-type cluster exists, as otherwise the input graph would not have a perfect partition. The cost of rebalancing is then at most $12$ \maciek{can show smaller constant than 12, but it does not matter that much}.
\end{proof}

\begin{theorem}
  There exists a $O(\ell)$-competitive algorithm for $k=3$.
\end{theorem}

\begin{proof}
  The adversary issues at most $3\ell$ requests, as otherwise the perfect partition would not exist. Each request issues at most one rebalancingfor the greedy algorithm, and by Theorem~\ref{rebalancing-cost}, the total cost of any algorithm is $O(k\cdot \ell)$.
\end{proof}

\section{Costly rebalance example $\Omega(k^2)$}

\maciek{ToDo}

\section{Trash: old versions etc.}


\subsection{Lower bound $\Omega(\ell)$}

\maciek{The most recent version of the lower bound is in $\Omega(l\cdot k)$ section. This is an early version!}
  \begin{enumerate}
    \item Cluster A component of size k-1. Define x.
    \item The input sequence (after these glueing) is to keep asking for x and someone of x's color
    \item Define a sequence of xs for any deterministic algorithm.
    \item Define what OPT should do: the cluster D and nodes d1 d2 that should be hidden from the sequence of xs?)
    \item (somewhere) define c(x): it is easy when x is not from D: then any would do; if x is from D, then issue request between non-d1/d2; also not defined for a1,ak-1, b1,bk-1 and ak, bk
    \item Argue that OPT does not pay for input sequence (after glueing)
    \item lower-bound the number of times we can issue (x, c(x)) request; until it encounters either d1 or d2 in place of x; this is lower-bounded by the total number of nodes-2 (d1 and d2 are last? they cannot be, though, but the furthest away should be at min distance k*l/2)
    \item also, this k*l/2 sequence is feasible, as the perfect partition exists: we can always issue this request (unless d1d2)
    \item the total cost of ALG, comp ratio
  \end{enumerate}


\maciek{I assume $\alpha = 1$ to simplify calculations, but everything should hold for general $\alpha$}

Model assumes the existence of a perfect partition of the input graph.
We present a lower bound for the competitive ratio of $\Omega(\ell)$ for any deterministic algorithm.
To this end, we use $k = 3$, i.e., the capacity of each server is $3$.


\begin{theorem}
  The competitive ratio of any deterministic algorithm for Online Balanced Partition (assuming the existence of a perfect partition of the input graph) is $\Omega(\ell)$.
  \label{th:lb_omega_l}
\end{theorem}
%Note that in the scenario with a perfect partition, both OPT and ALG always pays at most $O(\ell)$.

\begin{proof}
We say that nodes that belong to the same cluster in the initial configuration \emph{have the same color}.

Consider clusters $A$ and $B$ containing nodes $a_1, a_2, a_3$ and $b_1, b_2, b_3$, respectively.
The adversary begins with issuing three requests: $(a_1, a_2)$, $(b_1, b_2)$, and $(a_3, b_3)$.
Note that the algorithm is forced to move at least one of these components to a third cluster:
in general, if the algorithm does not keep each component within one cluster, the adversary might continue issuing requests among nodes of this component.



The algorithm places these three components in different clusters, and for this it pays at least $2$.
By $x$ (resp. $y$) we denote the third node from the cluster containing the component $(a_1, a_2)$ (resp. $(b_1, b_2)$).
%These nodes $x$ and $y$ are of the algorithm's choice, but.
During the execution of the algorithm, these nodes change, and by $x$ and $y$ we always denote the current nodes of the algorithm colocated with components $(a_1, a_2)$ and $(b_1, b_2)$.

%Let's call the cluster of $(a_1, a_2)$ the cluster $A_{ALG}$, the cluster of $(b_1, b_2)$ the cluster $B_{ALG}$ and the cluster of $(a_3, b_3)$ the cluster $C$. The configuration of ALG's clusters is then: $A_{ALG}$ contains $a_1, a_2,x$, the cluster $B_{ALG}$ contains $b_1, b_2,y$ and the cluster $C$ contains $a_3, b_3, z$, for some $x, y, z$ (of the algorithm's choice).

Our idea is that OPT pays for the request $(a_3, b_3)$ only (i.e., it moves this pair to a carefuly chosen cluster that we denote by $D$), and for OPT all other requests are free. 
OPT places these three components in clusters $A, B$ and $D$, paying $2$ for migrating $a_3$ and $b_3$.
The configuration of OPT's clusters is then: $A$ contains $a_1, a_2,d_1$, $B$ contains $b_1, b_2,d_2$ and $D$ contains $a_3, b_3, d_3$.
Note that the requests between nodes of the same color are free for OPT, with the exception of nodes from $A$, $B$, and most notably $D$.

OPT has the freedom of choice of the cluster $D$ depending on the choices of the algorithm.
We choose $D$ in such way that initially it does not contain neither $x$ nor $y$, and furthermore that the algorithm places any of nodes from $D$ at $x$'s or $y$'s place as the last possible move.
In other words, we inspect the sequence of $x$ and $y$ of the algorithm, and we choose $D$ to be the last cluster whose initial contents appears as the $x$ and $y$.
As there are $\ell$ clusters to choose from, ALG has to serve at least $\Omega(\ell)$ requests before any of $D$'s contents appear as $x$ or $y$.

From this point, OPT does not change its configuration, and the adversary continues to issue a request between $x$ and any other node with the same color as $x$
(note that by $x$ we might denote different node in every iteration, as $x$ is defined as a node colocated with a component $(a_1, a_2)$).
Upon receiving this request, ALG pays for it the cost at least $1$ and it increases its number of clusters that contain non-singleton components by $1$.
This procedure ends when ALG has no more clusters with singleton-only components left or ALG manages to put $d_1, d_2$ or $d_3$ in place of either $x$ or $y$.

At the begining, ALG has $\ell$ singleton-only components and each request increases their number by $1$.
Furthermore, before reaching either $d_1, d_2$ or $d_3$ in place of either $x$ or $y$, the algorithm must cycle through $\Omega(\ell)$ nodes from other clusters. This can be guaranteed as the choice of $D$ can depend on the actions of the deterministic algorithm.
In total, OPT pays $2$, and moreover ALG pays $\Omega(\ell)$, as it peforms a migration of two nodes for each request besides the first two.


%The next action of the adversary depends on the choice of $x, y, z$.
%If $x$ and $y$ have different color (i.e., initially they belong to different clusters), then we issue a request between $x$ and any other node with the same color as $x$. As $x$ do not intersect with $D$, the OPT has them co-located in one server, and it pays no cost for such requests. We issue such requests until $x$ and $y$ have the same color.

%Note that the adversary can foresee the actions of the algorithm, and may choose $D$ in such way, that $x$ cycles through all other clusters before reaching $D$, paying the cost of $\Omega(k)$, which would already suffice to show the lower bound.

%Then, $x$ and $y$ have the same color, and we issue a request $(x, y)$. As these have the same color (and there are different than $d_1, d_2$ and $d_3$), OPT pays no cost for this request, and ALG pays $2$ for migrating $x$ and $y$ to other cluster.
%We repeat the entire process, i.e., we force ALG to choose $x$ and $y$ of the same color, and issue such request that is free for OPT. This process can continue until ALG has no more clusters with singleton components, or it pays the cost $\Omega(k)$ already.

\end{proof}

\begin{observation}
  The lower bound of $\Omega(\ell)$ can be generalized for arbitrary $k = c\cdot 3$.
  The adversary starts with a serie of ``glueing requests'', so that each cluster contains 3 components of size $k/3$.
  We repeat the argument of Theorem~\ref{th:lb_omega_l} using these glued components instead of singletons.
  OPT pays $O(k)$ for migration of one such component, and ALG pays $\Omega(k \cdot \ell)$.
  \label{obs:lb_general_k}
\end{observation}

\begin{observation}
  The lower bound of $\Omega(\ell)$ holds even with $1/3-1/k$-augmentation, i.e., in scenarios where the capacity of each cluster of the algorithm is $(1+1/3)\cdot k - 1$, while the capacity of OPT's clusters is $k$.
  To this end we use the construction from Observation~\ref{obs:lb_general_k}.
  We observe that each cluster of the algorithm can fit exactly $3$ components of size $k/3$.
  \maciek{Note that this does not contradict the existence of $O((1+1/\epsilon)\cdot k \cdot \log(k))$ algorithm of Avin, Bienkowski et al, as it requires $2+\epsilon$-augmentation.}
\end{observation}


